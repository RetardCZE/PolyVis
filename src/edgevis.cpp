// === THIS PROJECT INCLUDES ===
#include "edgevis/structs/mesh.h"
#include "polyanya/search/polyviz.h"

#include "geomMesh/parsers/map_parser.h"

#include "utils/simple_clock.h"

#include <iomanip>
#include <boost/program_options.hpp>
#include <boost/filesystem.hpp>
#include <iostream>
#include <opencv2/opencv.hpp>

#include "edgevis/libs/clipper/clipper.hpp"

#ifndef INPUT_MAPS_DIR
#define INPUT_MAPS_DIR "."
#endif
#ifndef INPUT_CONVERTED_MAPS_DIR
#define INPUT_CONVERTED_MAPS_DIR "."
#endif

namespace po = boost::program_options;
namespace fs = boost::filesystem;
namespace cgm = cairo_geom_drawer;

/*
 * Argument parsing taken from trivis_examples.cc
*/

struct ProgramOptionVariables {
    std::string input_map_name = "undefined";
    std::string input_map_extension = ".mesh";
    std::string input_map_dir = INPUT_MAPS_DIR;
    std::string input_map_converted_dir = INPUT_CONVERTED_MAPS_DIR;
    std::string input_map_full_path;
    std::string input_map_converted_full_path;
    bool debug = false;
    bool save = false;
    bool robust = false;
    bool machine = true;
    int n_random_samples = 1;
    unsigned random_seed = std::random_device{}();
};

void AddProgramOptions(
        po::options_description &options_description,
        ProgramOptionVariables &pov
) {
    options_description.add_options()
            ("help,h", "Produce this help message. \n (*) Overwrites options: all.")
            ("map-name,m",
             po::value(&pov.input_map_name)->default_value(pov.input_map_name),
             "Map name.")
            ("map-ext",
             po::value(&pov.input_map_extension)->default_value(pov.input_map_extension),
             "Map file extension.")
            ("map-dir",
             po::value(&pov.input_map_dir)->default_value(pov.input_map_dir),
             "Map file directory.")
            ("map",
             po::value(&pov.input_map_full_path)->default_value(pov.input_map_full_path),
             "Full path to the map file. \n (*) Overwrites options: map_name, map_ext, map_dir.")
            ("n-random-samples,n",
             po::value(&pov.n_random_samples)->default_value(pov.n_random_samples),
             "How many random samples should be generated.")
            ("random-seed",
             po::value(&pov.random_seed)->default_value(pov.random_seed),
             "Seed for the random generator (generated by std::random_device{}() by default).")
            ("debug",
             po::bool_switch(&pov.debug)->default_value(pov.debug),
             "Run in debug mode.")
            ("save",
             po::bool_switch(&pov.save)->default_value(pov.save),
             "Log resulting polygons to files (cannot measure performance)..")
            ("robust ,r",
             po::bool_switch(&pov.robust)->default_value(pov.robust),
             "Turn on robust orientation test by Shewchuk.")
            ("machine",
             po::bool_switch(&pov.machine)->default_value(pov.machine),
             "Save output in format dedicated for further SW processing.");
}

char ParseProgramOptions(
        int argc,
        const char *const *argv,
        ProgramOptionVariables &pov
) {
    po::variables_map vm;
    po::options_description command_line_options;
    po::options_description options_description("General options");
    AddProgramOptions(options_description, pov);
    try {
        // Parse the command line arguments.
        command_line_options.add(options_description);
        po::store(po::parse_command_line(argc, argv, command_line_options), vm);
        po::notify(vm);
    } catch (const std::exception &e) {
        return 'e';
    }
    if (vm.count("help")) {
        // If '-h' or '--help' option, print the options and return 'h'.
        command_line_options.print(std::cout, 80);
        return 'h';
    }
    // Make input_file_name, input_file_extension, input_file_dir, and input_file_full_path consistent.
    if (pov.input_map_full_path.empty()) {
        pov.input_map_full_path = pov.input_map_dir + "/" + pov.input_map_name + (pov.input_map_extension.empty() ? "" : pov.input_map_extension);
        pov.input_map_converted_full_path = pov.input_map_converted_dir + "/" + pov.input_map_name + ".txt";
    } else {
        auto aux = fs::path(pov.input_map_full_path);
        pov.input_map_name = fs::change_extension(aux, "").filename().string();
        pov.input_map_extension = aux.extension().string();
        pov.input_map_dir = aux.parent_path().string();
    }
    return '0';
}

int body(ProgramOptionVariables pov) {
    std::ofstream results;
    results.open("results.dat", std::ios::out | std::ios::trunc);
    std::ofstream sideResults;
    sideResults.open("sideResults.dat", std::ios::out | std::ios::trunc);

    double time;
    custom::utils::SimpleClock clock;

    std::cout << "Preparing meshes, initializing Edgevis, TriVis and PolyVis solvers.\n";
    parsers::MapParser mapParser;
    parsers::Fade2DMesh fade2DMesh;
    parsers::MergedMesh mergedMesh;
    parsers::GeomMesh geomMeshTri;
    parsers::GeomMesh geomMeshPoly;
    parsers::GeomMesh IronHarvest;

    std::string mapName = pov.input_map_full_path;
    std::string convertedMapName = pov.input_map_converted_full_path;
    clock.Restart();
    mapParser.convertMapToMergedMesh(convertedMapName, mergedMesh);
    double mergedTime = clock.TimeInSeconds();
    mapParser.convertMergedMeshToGeomMesh(mergedMesh, geomMeshPoly);

    clock.Restart();
    int obstacles = 0;
    mapParser.convertMapToFade2DMesh(convertedMapName, fade2DMesh, obstacles);
    double CDTTime = clock.TimeInSeconds();
    mapParser.convertFade2DMeshToGeomMesh(fade2DMesh, IronHarvest);

    std::mt19937 rng(pov.random_seed); // random generator

    std::vector<edgevis::Point> verticesPoly;
    std::vector<edgevis::Point> points;

    edgevis::Point p;

    std::vector<Point> r_v;
    std::vector<Point> l_v;
    std::vector<Point> v;

    std::string name;
    parsers::GeomMesh geomMesh;
    geomMesh = IronHarvest;

    std::cout << "Tringular mesh has: " << geomMesh.polygons.size() << " triangles" << std::endl;
    std::cout << "Polygonal mesh has: " << geomMeshPoly.polygons.size() << " polygons" << std::endl;
    sideResults << pov.input_map_name << "\n"
                << geomMesh.vertices.size() << "\n"
                << obstacles << "\n"
                << geomMesh.polygons.size() << "\n"
                << geomMeshPoly.polygons.size() << "\n";

    clock.Restart();
    double initPolyTime = clock.TimeInSeconds();

    bool debug = pov.debug;
    bool save = pov.save;

    edgevis::Mesh EdgeVis(geomMesh);
    EdgeVis.useRobustOrientatation = pov.robust;

    clock.Restart();
    for (int i = 0; i < pov.n_random_samples; i++) {
        auto rp = EdgeVis.random_point(rng);
        p.x = rp.x;
        p.y = rp.y;
        points.push_back(p);

    }
    time = clock.TimeInSeconds();
    std::cout << pov.n_random_samples << " random points generated in: " << time << " seconds." << std::endl;

    if(true)
    {
        clock.Restart();
        EdgeVis.precompute_edges_searchnodes();
        std::cout << "\nEdgevis\n";
        std::cout << "Preprocessing time for Edge Visibility was " <<
                  time << " seconds.\n";
        clock.Restart();

        EdgeVis.precompute_edges_optimnodesV1();
        time = clock.TimeInSeconds();
        std::cout << "Preprocessing time for OptimNodesV1 was " <<
                  time << " seconds.\n";

        clock.Restart();
        EdgeVis.precompute_edges_optimnodesV2();
        time = clock.TimeInSeconds();
        std::cout << "Preprocessing time for OptimNodesV2 was " <<
                  time << " seconds.\n";

        clock.Restart();
        EdgeVis.precompute_edges_optimnodesV3();
        time = clock.TimeInSeconds();
        std::cout << "Preprocessing time for OptimNodesV3 was " <<
                  time << " seconds.\n";

        bool debug = false;
        double steps;
        int debugEdge = 0;
        clock.Restart();
        for (auto pos: points) {
            verticesPoly = EdgeVis.find_point_visibility_optim1(pos, debug, steps, debugEdge);
        }

        time = clock.TimeInSeconds();
        std::cout << "EdgeVis v1: " << "\n";
        std::cout << "Total computation time: " << time << " seconds.\n";
        std::cout << "Mean computation time: " << time / pov.n_random_samples << " seconds/point.\n";
        std::cout << std::endl;

        clock.Restart();
        for (auto pos: points) {
            verticesPoly = EdgeVis.find_point_visibility_optim2(pos, debug, steps, debugEdge);
            //EdgeVis.reset_visu();
            //EdgeVis.visualise_point(pos, 0, false);
            //EdgeVis.visualise_polygon(verticesPoly, 2, true);
            //getchar();
        }

        time = clock.TimeInSeconds();
        std::cout << "EdgeVis v2: " << "\n";
        std::cout << "Total computation time: " << time << " seconds.\n";
        std::cout << "Mean computation time: " << time / pov.n_random_samples << " seconds/point.\n";
        std::cout << std::endl;

        clock.Restart();
        for (auto pos: points) {
            verticesPoly = EdgeVis.find_point_visibility_optim3(pos, debug, steps, debugEdge);
        }

        time = clock.TimeInSeconds();
        std::cout << "EdgeVis v3: " << "\n";
        std::cout << "Total computation time: " << time << " seconds.\n";
        std::cout << "Mean computation time: " << time / pov.n_random_samples << " seconds/point.\n";
        std::cout << std::endl;

        clock.Restart();
        for (auto pos: points) {
            verticesPoly = EdgeVis.find_point_visibility_optim4(pos);
        }

        time = clock.TimeInSeconds();
        std::cout << "EdgeVis v4: " << "\n";
        std::cout << "Total computation time: " << time << " seconds.\n";
        std::cout << "Mean computation time: " << time / pov.n_random_samples << " seconds/point.\n";
        std::cout << std::endl;
        /*
        double mem = 0;
        for (auto pos: points) {
            //EdgeVis.reset_visu();
            verticesPoly = EdgeVis.find_point_visibility_optim1(pos, debug, steps, debugEdge);
            auto polymem = verticesPoly;
            ClipperLib::Path p1, p2, p3;
            for (const auto& point : verticesPoly) {
                p1.push_back(ClipperLib::IntPoint(static_cast<long>(point.x),
                                                  static_cast<long>(point.y )));
            }
            //EdgeVis.visualise_polygon(verticesPoly, 0, false);

            verticesPoly = EdgeVis.find_point_visibility_optim2(pos, debug, steps, debugEdge);
            for (const auto& point : verticesPoly) {
                p2.push_back(ClipperLib::IntPoint(static_cast<long>(point.x),
                                                  static_cast<long>(point.y )));
            }
            //EdgeVis.visualise_polygon(verticesPoly, 1, false);

            verticesPoly = EdgeVis.find_point_visibility_optim3(pos, debug, steps, debugEdge);
            for (const auto& point : verticesPoly) {
                p3.push_back(ClipperLib::IntPoint(static_cast<long>(point.x),
                                                  static_cast<long>(point.y )));
            }
            //EdgeVis.visualise_polygon(verticesPoly, 2, false);

            ClipperLib::Paths diff_p1_p2, diff_p1_p3, diff_p2_p3;
            ClipperLib::Clipper clipper;
            clipper.AddPath(p1, ClipperLib::ptSubject, true);
            clipper.AddPath(p2, ClipperLib::ptClip, true);
            clipper.Execute(ClipperLib::ctDifference, diff_p1_p2);

            clipper.Clear();
            clipper.AddPath(p1, ClipperLib::ptSubject, true);
            clipper.AddPath(p3, ClipperLib::ptClip, true);
            clipper.Execute(ClipperLib::ctDifference, diff_p1_p3);

            clipper.Clear();
            clipper.AddPath(p2, ClipperLib::ptSubject, true);
            clipper.AddPath(p3, ClipperLib::ptClip, true);
            clipper.Execute(ClipperLib::ctDifference, diff_p2_p3);

// Calculate the areas of the differences
            double area_diff_p1_p2 = 0.0;
            double area_diff_p1_p3 = 0.0;
            double area_diff_p2_p3 = 0.0;

            for (const auto& path : diff_p1_p2) {
                area_diff_p1_p2 += ClipperLib::Area(path);
            }

            for (const auto& path : diff_p1_p3) {
                area_diff_p1_p3 += ClipperLib::Area(path);
            }

            for (const auto& path : diff_p2_p3) {
                area_diff_p2_p3 += ClipperLib::Area(path);
            }

// Output the areas of the differences

            double top_diff = std::max(area_diff_p1_p3, std::max(area_diff_p2_p3, area_diff_p1_p2));
            double top_area = std::max(ClipperLib::Area(p1), std::max(ClipperLib::Area(p2), ClipperLib::Area(p3)));
            mem = std::max(mem, top_diff/top_area);

        }
         */
    }

    if(false){

        EdgeVis.precompute_edges_searchnodes();
        EdgeVis.precompute_edges_optimnodesV1();
        EdgeVis.precompute_edges_optimnodesV2();
        EdgeVis.precompute_edges_optimnodesV3();

        bool debug = false;
        double steps;
        int debugEdge = 0;
        clock.Restart();
        double mem = 0;
        int ctr = 0;
        for (auto pos: points) {
            ctr++;
            //EdgeVis.reset_visu();
            //std::cout << pos << std::endl;
            //EdgeVis.visualise_point(pos, 0, true);

            verticesPoly = EdgeVis.find_point_visibility_optim1(pos, debug, steps, debugEdge);

            auto polymem = verticesPoly;
            ClipperLib::Path p1, p2, p3;
            for (const auto& point : verticesPoly) {
                p1.push_back(ClipperLib::IntPoint(static_cast<long>(point.x),
                                                  static_cast<long>(point.y )));
            }

            verticesPoly = EdgeVis.find_point_visibility_optim2(pos, debug, steps, debugEdge);
            for (const auto& point : verticesPoly) {
                p2.push_back(ClipperLib::IntPoint(static_cast<long>(point.x),
                                                  static_cast<long>(point.y )));
            }

            verticesPoly = EdgeVis.find_point_visibility_optim3(pos, debug, steps, debugEdge);
            for (const auto& point : verticesPoly) {
                p3.push_back(ClipperLib::IntPoint(static_cast<long>(point.x),
                                                  static_cast<long>(point.y )));
            }

            ClipperLib::Paths diff_p1_p2, diff_p1_p3, diff_p2_p3;
            ClipperLib::Clipper clipper;
            clipper.AddPath(p1, ClipperLib::ptSubject, true);
            clipper.AddPath(p2, ClipperLib::ptClip, true);
            clipper.Execute(ClipperLib::ctDifference, diff_p1_p2);

            clipper.Clear();
            clipper.AddPath(p1, ClipperLib::ptSubject, true);
            clipper.AddPath(p3, ClipperLib::ptClip, true);
            clipper.Execute(ClipperLib::ctDifference, diff_p1_p3);

            clipper.Clear();
            clipper.AddPath(p2, ClipperLib::ptSubject, true);
            clipper.AddPath(p3, ClipperLib::ptClip, true);
            clipper.Execute(ClipperLib::ctDifference, diff_p2_p3);

            double area_diff_p1_p2 = 0.0;
            double area_diff_p1_p3 = 0.0;
            double area_diff_p2_p3 = 0.0;

            for (const auto& path : diff_p1_p2) {
                area_diff_p1_p2 += ClipperLib::Area(path);
            }

            for (const auto& path : diff_p1_p3) {
                area_diff_p1_p3 += ClipperLib::Area(path);
            }

            for (const auto& path : diff_p2_p3) {
                area_diff_p2_p3 += ClipperLib::Area(path);
            }

            // Output the areas of the differences

            double top_diff = std::max(area_diff_p1_p3, std::max(area_diff_p2_p3, area_diff_p1_p2));
            double top_area = std::max(ClipperLib::Area(p1), std::max(ClipperLib::Area(p2), ClipperLib::Area(p3)));
            std::cout << ctr << " - " << top_diff/top_area << std::endl;
            mem = std::max(mem, top_diff/top_area);

        }
        std::cout << mem << std::endl;

    }

    if(true)
    {
        edgevis::Mesh EdgeVis3(geomMesh);
        EdgeVis3.useRobustOrientatation = pov.robust;
        clock.Restart();
        EdgeVis3.TEAItems = 200;
        EdgeVis3.realloc_TEA_mem(EdgeVis3.TEAItems);
        int ctr = 0;
        for (auto pos: points) {

            //std::cout << ++ctr << std::endl;
            verticesPoly = EdgeVis3.find_point_visibility_TEA(pos, debug);
            //EdgeVis3.reset_visu();
            //EdgeVis3.visualise_point(pos, 0, false);
            //EdgeVis3.visualise_polygon(verticesPoly, 2, true);
            //getchar();
        }
        EdgeVis3.allocTEA.clear();
        time = clock.TimeInSeconds();
        std::cout << "TEA: " << "\n";
        std::cout << "Total computation time: " << time << " seconds.\n";
        std::cout << "Mean computation time: " << time / pov.n_random_samples << " seconds/point.\n";
        std::cout << std::endl;
        EdgeVis3.reset_visu();
        EdgeVis3.visualise_polygon(verticesPoly, 2, true);
        EdgeVis3.visualise_point(points.back(), 0, true);
    }

    if(true)
    {
        edgevis::Mesh EdgeVis2(geomMeshPoly);
        EdgeVis2.useRobustOrientatation = pov.robust;
        clock.Restart();
        EdgeVis2.PEAItems = 200;
        EdgeVis2.realloc_PEA_mem(EdgeVis2.PEAItems);
        for (auto pos: points) {
            //EdgeVis2.reset_visu();
            verticesPoly = EdgeVis2.find_point_visibility_PEA(pos, debug);

            //std::cout <<"size: " << verticesPoly.size()<<std::endl;
            //EdgeVis2.visualise_polygon(verticesPoly, 2, false);
            //EdgeVis2.visualise_point(pos, 0, true);
            //getchar();
        }
        EdgeVis2.allocPEA.clear();
        time = clock.TimeInSeconds();
        std::cout << "PEA: " << "\n";
        std::cout << "Total computation time: " << time << " seconds.\n";
        std::cout << "Mean computation time: " << time / pov.n_random_samples << " seconds/point.\n";
        std::cout << std::endl;
        EdgeVis2.reset_visu();
        EdgeVis2.visualise_polygon(verticesPoly, 2, true);
        EdgeVis2.visualise_point(points.back(), 0, true);
    }

    if(false)
    {

        polyanya::PolyVis polyvis(geomMesh);
        std::vector<polyanya::Point> pointsP = polyvis.generate_points(pov.n_random_samples);
        pointsP.clear();
        for(auto pos : points){
            pointsP.push_back({pos.x, pos.y});
        }
        std::vector<polyanya::Point> results;
        clock.Restart();
        for (auto pos: pointsP) {
            results = polyvis.get_visibility_polygon(pos);
        }

        time = clock.TimeInSeconds();
        std::cout << "TEA original: " << "\n";
        std::cout << "Total computation time: " << time << " seconds.\n";
        std::cout << "Mean computation time: " << time / pov.n_random_samples << " seconds/point.\n";
        std::cout << std::endl;
    }


    if(false)
    {

        polyanya::PolyVis polyvis(geomMeshPoly);
        std::vector<polyanya::Point> pointsP = polyvis.generate_points(pov.n_random_samples);
        pointsP.clear();
        for(auto pos : points){
            pointsP.push_back({pos.x, pos.y});
        }
        std::vector<polyanya::Point> results;
        clock.Restart();
        for (auto pos: pointsP) {
            results = polyvis.get_visibility_polygon(pos);
        }

        time = clock.TimeInSeconds();
        std::cout << "PEA original: " << "\n";
        std::cout << "Total computation time: " << time << " seconds.\n";
        std::cout << "Mean computation time: " << time / pov.n_random_samples << " seconds/point.\n";
        std::cout << std::endl;
    }

    return 0;
}

int main(
        int argc,
        const char *const *argv
) {
    ProgramOptionVariables pov;
    char c = ParseProgramOptions(argc, argv, pov);
    if (c == 'h') {
        return EXIT_SUCCESS;
    } else if (c == 'e') {
        return EXIT_FAILURE;
    } else {
        return body(pov);
    }
}
