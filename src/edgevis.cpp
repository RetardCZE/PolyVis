// === THIS PROJECT INCLUDES ===
#include "edgevis/structs/mesh.h"
#include "polyanya/search/polyviz.h"
#include "OG_poly/structs/mesh.h"
#include "OG_poly/search/searchinstance.h"
#include "geomMesh/parsers/map_parser.h"

// #include "utils/simple_clock.h"

#include <iomanip>
#include <boost/program_options.hpp>
#include <boost/filesystem.hpp>
#include <iostream>
#include <opencv2/opencv.hpp>

#include "edgevis/libs/clipper/clipper.hpp"

#ifndef INPUT_MAPS_DIR
#define INPUT_MAPS_DIR "."
#endif
#ifndef INPUT_CONVERTED_MAPS_DIR
#define INPUT_CONVERTED_MAPS_DIR "."
#endif

namespace po = boost::program_options;
namespace fs = boost::filesystem;
namespace cgm = cairo_geom_drawer;

/*
 * Argument parsing taken from trivis_examples.cc
*/

struct ProgramOptionVariables {
    std::string input_map_name = "undefined";
    std::string input_map_extension = ".mesh";
    std::string input_map_dir = INPUT_MAPS_DIR;
    std::string input_map_converted_dir = INPUT_CONVERTED_MAPS_DIR;
    std::string input_map_full_path;
    std::string input_map_converted_full_path;
    bool debug = false;
    bool save = false;
    bool robust = false;
    bool compare = false;
    int n_random_samples = 1;
    int algorithm = 0;
    unsigned random_seed = std::random_device{}();
};

void AddProgramOptions(
        po::options_description &options_description,
        ProgramOptionVariables &pov
) {
    options_description.add_options()
            ("help,h", "Produce this help message. \n (*) Overwrites options: all.")
            ("map-name,m",
             po::value(&pov.input_map_name)->default_value(pov.input_map_name),
             "Map name.")
            ("map-ext",
             po::value(&pov.input_map_extension)->default_value(pov.input_map_extension),
             "Map file extension.")
            ("map-dir",
             po::value(&pov.input_map_dir)->default_value(pov.input_map_dir),
             "Map file directory.")
            ("map",
             po::value(&pov.input_map_full_path)->default_value(pov.input_map_full_path),
             "Full path to the map file. \n (*) Overwrites options: map_name, map_ext, map_dir.")
            ("n-random-samples,n",
             po::value(&pov.n_random_samples)->default_value(pov.n_random_samples),
             "How many random samples should be generated.")
            ("random-seed",
             po::value(&pov.random_seed)->default_value(pov.random_seed),
             "Seed for the random generator (generated by std::random_device{}() by default).")
            ("debug",
             po::bool_switch(&pov.debug)->default_value(pov.debug),
             "Run in debug mode.")
            ("save",
             po::bool_switch(&pov.save)->default_value(pov.save),
             "Log resulting polygons to files (cannot measure performance)..")
            ("robust ,r",
             po::bool_switch(&pov.robust)->default_value(pov.robust),
             "Turn on robust orientation test by Shewchuk.")
            ("compare",
             po::bool_switch(&pov.compare)->default_value(pov.compare),
             "Ignore other arguments and runs comparison for local logs. Need all logs from 0 to 4.")
            ("algorithm, a",
             po::value(&pov.algorithm)->default_value(pov.algorithm),
             "Select computation algorithm [T - 0, E1 - 1, E2 - 2, E3 - 3, E4 - 4].");
}

char ParseProgramOptions(
        int argc,
        const char *const *argv,
        ProgramOptionVariables &pov
) {
    po::variables_map vm;
    po::options_description command_line_options;
    po::options_description options_description("General options");
    AddProgramOptions(options_description, pov);
    try {
        // Parse the command line arguments.
        command_line_options.add(options_description);
        po::store(po::parse_command_line(argc, argv, command_line_options), vm);
        po::notify(vm);
    } catch (const std::exception &e) {
        return 'e';
    }
    if (vm.count("help")) {
        // If '-h' or '--help' option, print the options and return 'h'.
        command_line_options.print(std::cout, 80);
        return 'h';
    }
    // Make input_file_name, input_file_extension, input_file_dir, and input_file_full_path consistent.
    if (pov.input_map_full_path.empty()) {
        pov.input_map_full_path = pov.input_map_dir + "/" + pov.input_map_name + (pov.input_map_extension.empty() ? "" : pov.input_map_extension);
        pov.input_map_converted_full_path = pov.input_map_converted_dir + "/" + pov.input_map_name + ".txt";
    } else {
        auto aux = fs::path(pov.input_map_full_path);
        pov.input_map_name = fs::change_extension(aux, "").filename().string();
        pov.input_map_extension = aux.extension().string();
        pov.input_map_dir = aux.parent_path().string();
    }
    return '0';
}

parsers::GeomMesh
load_mesh(std::string map_full_path, bool polygonal){
    parsers::MapParser mapParser;
    parsers::Fade2DMesh fade2DMesh;
    parsers::MergedMesh mergedMesh;
    parsers::GeomMesh result;
    int obstacles;
    double time;
    custom::utils::SimpleClock clock;
    clock.Restart();
    if(!polygonal){
        mapParser.convertMapToFade2DMesh(map_full_path, fade2DMesh, obstacles);
        mapParser.convertFade2DMeshToGeomMesh(fade2DMesh, result);
        time = clock.TimeInSeconds();
        std::cout << "[M-CDT]-" << time << std::endl;
    }else{
        mapParser.convertMapToMergedMesh(map_full_path, mergedMesh);
        mapParser.convertMergedMeshToGeomMesh(mergedMesh, result);
        time = clock.TimeInSeconds();
        std::cout << "[CDT]-" << time << std::endl;
    }
    return result;
}

std::vector<edgevis::Point>
generate_random_points(edgevis::Mesh &mesh, int count, std::mt19937 seed){
    std::vector<edgevis::Point> points;
    edgevis::Point p;
    for (int i = 0; i < count; i++) {
        auto rp = mesh.random_point(seed);
        p.x = rp.x;
        p.y = rp.y;
        points.push_back(p);
    }
    return points;
}

void
test_edgevis_basic(edgevis::Mesh &mesh, std::vector<edgevis::Point> &observers, bool save){
    double time_preprocess;
    custom::utils::SimpleClock clock;
    clock.Restart();
    mesh.precompute_edges_optimnodesV1();
    time_preprocess = clock.TimeInSeconds();

    double T1, T2, T3;
    std::vector<edgevis::Point> results;

    for (auto pos: observers) {
        results = mesh.find_point_visibility_optim1(pos, T1, T2, T3);

    }

    return;
}

void
test_edgevis_precompute_always_visible(edgevis::Mesh &mesh, std::vector<edgevis::Point> &observers, bool save){
    double time;
    custom::utils::SimpleClock clock;
    clock.Restart();
    mesh.precompute_edges_optimnodesV2();
    time = clock.TimeInSeconds();
    if(!save) std::cout << "[E2-prep]-" << time << std::endl;
    bool debug;
    double steps;
    int debugEdge;
    std::vector<edgevis::Point> results;
    clock.Restart();
    for (auto pos: observers) {
        results = mesh.find_point_visibility_optim2(pos);
        if(save){
            std::cout << "S--" << pos << "---" << results.size() << "\n";
            for(auto p : results){
                std::cout << p << "\n";
            }
        }
    }
    time = clock.TimeInSeconds();
    if(!save) std::cout << "[E2-prep]-" << time << std::endl;
    return;
}

void
test_edgevis_online_prunning(edgevis::Mesh &mesh, std::vector<edgevis::Point> &observers, bool save){
    double time;
    custom::utils::SimpleClock clock;
    clock.Restart();
    mesh.precompute_edges_optimnodesV3();
    time = clock.TimeInSeconds();
    if(!save) std::cout << "[E3-prep]-" << time << std::endl;
    bool debug;
    double steps;
    int debugEdge;
    std::vector<edgevis::Point> results;
    clock.Restart();
    for (auto pos: observers) {
        results = mesh.find_point_visibility_optim3(pos);
        if(save){
            std::cout << "S--" << pos << "---" << results.size() << "\n";
            for(auto p : results){
                std::cout << p << "\n";
            }
        }
    }
    time = clock.TimeInSeconds();
    if(!save) std::cout << "[E3-time]-" << time << std::endl;
    return;
}

void
test_edgevis_online_prunning_and_precompute_visible(edgevis::Mesh &mesh, std::vector<edgevis::Point> &observers, bool save){
    double time;
    custom::utils::SimpleClock clock;
    clock.Restart();
    mesh.precompute_edges_optimnodesV2();
    mesh.precompute_edges_optimnodesV3();
    time = clock.TimeInSeconds();
    if(!save) std::cout << "[E4-prep]-" << time << std::endl;
    std::vector<edgevis::Point> results;
    clock.Restart();
    for (auto pos: observers) {
        results = mesh.find_point_visibility_optim4(pos);
        if(save){
            std::cout << "S--" << pos << "---" << results.size() << "\n";
            for(auto p : results){
                std::cout << p << "\n";
            }
        }
    }
    time = clock.TimeInSeconds();
    if(!save) std::cout << "[E4-time]-" << time << std::endl;
    return;
}

void
test_TEA(edgevis::Mesh &mesh, std::vector<edgevis::Point> &observers, bool save){

    mesh.TEAItems = 200;
    mesh.realloc_TEA_mem(mesh.TEAItems);
    std::vector<edgevis::Point> results;
    double T1, T2, T3;
    for (auto pos: observers) {
        results = mesh.find_point_visibility_TEA(pos, T1, T2, T3);

    }
    mesh.allocTEA.clear();
    return;
}

void
test_PEA(edgevis::Mesh &mesh, std::vector<edgevis::Point> &observers, bool save){

    mesh.PEAItems = 200;
    mesh.realloc_TEA_mem(mesh.PEAItems);
    std::vector<edgevis::Point> results;

    double T1, T2, T3;
    for (auto pos: observers) {
        results = mesh.find_point_visibility_PEA(pos, T1, T2, T3);
    }
    mesh.allocPEA.clear();
    return;
}

void
compare_polygons(std::vector<std::vector<edgevis::Point>> &visibilityPolygons){
    ClipperLib::Clipper clipper;
    std::vector<ClipperLib::Path> paths;
    paths.resize(visibilityPolygons.size());
    int path = 0;
    for(auto polygon : visibilityPolygons){
        for(auto point: polygon){
            paths[path].push_back(ClipperLib::IntPoint(static_cast<long>(point.x),
                                                       static_cast<long>(point.y )));
        }
        path++;
    }

    ClipperLib::Paths difference;

    std::vector<double> results; // first is area of reference then relative error of other polygons
    results.resize(paths.size());
    results[0] = ClipperLib::Area(paths[0]);
    double area;
    path = 0;
    for(auto p : paths){
        if(path++ == 0) continue; // skip first 'reference' path
        clipper.Clear();
        difference.clear();
        area = 0;
        clipper.AddPath(paths[0], ClipperLib::ptSubject, true);
        clipper.AddPath(p, ClipperLib::ptClip, true);
        clipper.Execute(ClipperLib::ctDifference, difference);
        for (const auto& dPath : difference) {
            area += ClipperLib::Area(dPath);
        }
        results[path] = area; // /results[0]; //difference between visibility polygons normalized to area of the map
        path++;
    }
    std::cout << results[0] << " | " << results[1] << " | " << results[2] << " | " << results[3] << " | " << results[4] << std::endl;
    return;
}

std::vector<edgevis::Point> read_one_point(std::ifstream& file) {
    std::vector<edgevis::Point> polygon;
    std::string line;
    edgevis::Point p;
    // Find the line that starts with "S--("
    while (std::getline(file, line)) {
        if (line.find("S--(") != std::string::npos) {
            break;
        }
    }

    // Extract seeker point and number of points
    double seekerX, seekerY;
    int numberOfPoints;
    if (sscanf(line.c_str(), "S--(%lf, %lf)---%d", &seekerX, &seekerY, &numberOfPoints) != 3) {
        std::cerr << "Invalid format for seeker line." << std::endl;
        return polygon;  // Return an empty polygon if the format is invalid
    }


    // Read the points
    for (int i = 0; i < numberOfPoints; i++) {
        if (!std::getline(file, line)) {
            std::cerr << "Unexpected end of file." << std::endl;
            return polygon;  // Return what has been read so far if unexpected end of file
        }

        // Extract x and y coordinates
        double x, y;
        if (sscanf(line.c_str(), "(%lf, %lf)", &x, &y) != 2) {
            std::cerr << "Invalid format for point line." << std::endl;
            return polygon;  // Return what has been read so far if invalid format
        }
        // Convert to edgevis::Point and add to the polygon

        p.x = x;
        p.y = y;
        polygon.push_back(p);
    }
    return polygon;
}

void
comparison_mode(){
    std::vector<std::ifstream> files;
    files.resize(5);
    int points;
    for (int i = 0; i <= 4; i++) {
        // Construct the file name
        std::string fileName = "results" + std::to_string(i) + ".log";

        // Open the file
        files[i].open(fileName);

        // Check if the file is successfully opened
        if (files[i].is_open()) {
            // Read the first three lines
            for (int lineNum = 0; lineNum < 4; lineNum++) {
                std::string line;
                std::getline(files[i], line);
                if(lineNum == 2) { points = std::stoi(line); }
                // Check if it's the second line and if it contains "AREAS"
                if (lineNum == 1 && !(line.find("AREAS") != std::string::npos)) {
                    std::cerr << "At least one file is invalid, ending comparisson." << std::endl;
                    return;
                }
            }

        } else {
            std::cerr << "Unable to open file: " << fileName << std::endl;
            return;
        }
    }
    std::cout << points << std::endl;
    std::vector<std::vector<edgevis::Point>> visibilityPolygons;
    visibilityPolygons.resize(5);
    for(int j = 0; j < points; j++) {
        for (int i = 0; i <= 4; i++) {
            visibilityPolygons[i] = read_one_point(files[i]);
        }
        compare_polygons(visibilityPolygons);
    }
    for (int i = 0; i <= 4; i++) {
        files[i].close();
    }
    return;
}

int new_body(ProgramOptionVariables pov){
    if(pov.compare){
        comparison_mode();
        return 0;
    }
    std::string mapName = pov.input_map_converted_full_path;
    bool polygonal = false;
    // Redirect standard output to a file named "results"
    std::ofstream outputFile("results" + std::to_string(pov.algorithm) + ".log");
    std::streambuf *coutBuffer = std::cout.rdbuf(); // Save cout's buffer
    std::cout.rdbuf(outputFile.rdbuf()); // Redirect cout to the file

    std::cout << "---DATA-START---" << std::endl;
    if(pov.save){
        if(pov.n_random_samples > 10000){
            std::cout << "Dont save more than 10K polygons! Ending the script." << std::endl;
            return 1;
        }
        std::cout << "AREAS" << std::endl;
    }else{
        std::cout << "TIMES" << std::endl;
    }
    std::cout << pov.n_random_samples << std::endl;
    parsers::GeomMesh gMesh = load_mesh(mapName, polygonal);
    std::mt19937 rng(pov.random_seed);
    edgevis::Mesh mesh(gMesh);
    std::vector<edgevis::Point> observers = generate_random_points(mesh, pov.n_random_samples, rng);
    mesh.useRobustOrientatation = pov.robust;

    switch(pov.algorithm){
        case 0:
            test_TEA(mesh, observers, pov.save);
            break;
        case 1:
            test_edgevis_basic(mesh, observers, pov.save);
            break;
        case 2:
            test_PEA(mesh, observers, pov.save);
            break;
        default:
            break;
    }
    std::cout << "---DATA-END---" << std::endl;
    std::cout.rdbuf(coutBuffer);
    return 0;
}

int body(ProgramOptionVariables pov) {
    std::ofstream results;
    results.open("results.dat", std::ios::out | std::ios::trunc);
    std::ofstream sideResults;
    sideResults.open("sideResults.dat", std::ios::out | std::ios::trunc);

    double time;
    custom::utils::SimpleClock clock;

    std::cout << "Preparing meshes, initializing Edgevis, TriVis and PolyVis solvers.\n";
    parsers::MapParser mapParser;
    parsers::Fade2DMesh fade2DMesh;
    parsers::MergedMesh mergedMesh;
    parsers::GeomMesh geomMeshTri;
    parsers::GeomMesh geomMeshPoly;
    parsers::GeomMesh IronHarvest;

    std::string mapName = pov.input_map_full_path;
    std::string convertedMapName = pov.input_map_converted_full_path;
    clock.Restart();
    mapParser.convertMapToMergedMesh(convertedMapName, mergedMesh);
    double mergedTime = clock.TimeInSeconds();
    mapParser.convertMergedMeshToGeomMesh(mergedMesh, geomMeshPoly);

    clock.Restart();
    int obstacles = 0;
    mapParser.convertMapToFade2DMesh(convertedMapName, fade2DMesh, obstacles);
    double CDTTime = clock.TimeInSeconds();
    mapParser.convertFade2DMeshToGeomMesh(fade2DMesh, IronHarvest);

    std::mt19937 rng(pov.random_seed); // random generator

    std::vector<edgevis::Point> verticesPoly;
    std::vector<edgevis::Point> points;

    edgevis::Point p;

    std::vector<Point> r_v;
    std::vector<Point> l_v;
    std::vector<Point> v;

    std::string name;
    parsers::GeomMesh geomMesh;
    geomMesh = IronHarvest;

    std::cout << "Tringular mesh has: " << geomMesh.polygons.size() << " triangles" << std::endl;
    std::cout << "Polygonal mesh has: " << geomMeshPoly.polygons.size() << " polygons" << std::endl;
    sideResults << pov.input_map_name << "\n"
                << geomMesh.vertices.size() << "\n"
                << obstacles << "\n"
                << geomMesh.polygons.size() << "\n"
                << geomMeshPoly.polygons.size() << "\n";

    clock.Restart();
    double initPolyTime = clock.TimeInSeconds();

    bool debug = pov.debug;
    bool save = pov.save;

    edgevis::Mesh EdgeVis(geomMesh);
    EdgeVis.useRobustOrientatation = pov.robust;

    clock.Restart();
    for (int i = 0; i < pov.n_random_samples; i++) {
        auto rp = EdgeVis.random_point(rng);
        p.x = rp.x;
        p.y = rp.y;
        points.push_back(p);

    }
    time = clock.TimeInSeconds();
    std::cout << pov.n_random_samples << " random points generated in: " << time << " seconds." << std::endl;
    bool timeM = true;
    if(timeM)
    {
        clock.Restart();
        EdgeVis.precompute_edges_searchnodes();
        std::cout << "\nEdgevis\n";
        std::cout << "Preprocessing time for Edge Visibility was " <<
                  time << " seconds.\n";
        clock.Restart();

        EdgeVis.precompute_edges_optimnodesV1();
        time = clock.TimeInSeconds();
        std::cout << "Preprocessing time for OptimNodesV1 was " <<
                  time << " seconds.\n";

        clock.Restart();
        EdgeVis.precompute_edges_optimnodesV2();
        time = clock.TimeInSeconds();
        std::cout << "Preprocessing time for OptimNodesV2 was " <<
                  time << " seconds.\n";

        clock.Restart();
        EdgeVis.precompute_edges_optimnodesV3();
        time = clock.TimeInSeconds();
        std::cout << "Preprocessing time for OptimNodesV3 was " <<
                  time << " seconds.\n";

        bool debug = false;
        double steps;
        double T1, T2, T3;
        int debugEdge = 0;
        clock.Restart();
        for (auto pos: points) {
            verticesPoly = EdgeVis.find_point_visibility_optim1(pos, T1, T2, T3);
        }

        time = clock.TimeInSeconds();
        std::cout << "EdgeVis v1: " << "\n";
        std::cout << "Total computation time: " << time << " seconds.\n";
        std::cout << "Mean computation time: " << time / pov.n_random_samples << " seconds/point.\n";
        std::cout << std::endl;

        clock.Restart();
        for (auto pos: points) {
            verticesPoly = EdgeVis.find_point_visibility_optim2(pos);
            //EdgeVis.reset_visu();
            //EdgeVis.visualise_point(pos, 0, false);
            //EdgeVis.visualise_polygon(verticesPoly, 2, true);
            //getchar();
        }

        time = clock.TimeInSeconds();
        std::cout << "EdgeVis v2: " << "\n";
        std::cout << "Total computation time: " << time << " seconds.\n";
        std::cout << "Mean computation time: " << time / pov.n_random_samples << " seconds/point.\n";
        std::cout << std::endl;

        clock.Restart();
        for (auto pos: points) {
            verticesPoly = EdgeVis.find_point_visibility_optim3(pos);
        }

        time = clock.TimeInSeconds();
        std::cout << "EdgeVis v3: " << "\n";
        std::cout << "Total computation time: " << time << " seconds.\n";
        std::cout << "Mean computation time: " << time / pov.n_random_samples << " seconds/point.\n";
        std::cout << std::endl;

        clock.Restart();
        for (auto pos: points) {
            verticesPoly = EdgeVis.find_point_visibility_optim4(pos);
        }

        time = clock.TimeInSeconds();
        std::cout << "EdgeVis v4: " << "\n";
        std::cout << "Total computation time: " << time << " seconds.\n";
        std::cout << "Mean computation time: " << time / pov.n_random_samples << " seconds/point.\n";
        std::cout << std::endl;
        /*
        double mem = 0;
        for (auto pos: points) {
            //EdgeVis.reset_visu();
            verticesPoly = EdgeVis.find_point_visibility_optim1(pos, debug, steps, debugEdge);
            auto polymem = verticesPoly;
            ClipperLib::Path p1, p2, p3;
            for (const auto& point : verticesPoly) {
                p1.push_back(ClipperLib::IntPoint(static_cast<long>(point.x),
                                                  static_cast<long>(point.y )));
            }
            //EdgeVis.visualise_polygon(verticesPoly, 0, false);

            verticesPoly = EdgeVis.find_point_visibility_optim2(pos, debug, steps, debugEdge);
            for (const auto& point : verticesPoly) {
                p2.push_back(ClipperLib::IntPoint(static_cast<long>(point.x),
                                                  static_cast<long>(point.y )));
            }
            //EdgeVis.visualise_polygon(verticesPoly, 1, false);

            verticesPoly = EdgeVis.find_point_visibility_optim3(pos, debug, steps, debugEdge);
            for (const auto& point : verticesPoly) {
                p3.push_back(ClipperLib::IntPoint(static_cast<long>(point.x),
                                                  static_cast<long>(point.y )));
            }
            //EdgeVis.visualise_polygon(verticesPoly, 2, false);

            ClipperLib::Paths diff_p1_p2, diff_p1_p3, diff_p2_p3;
            ClipperLib::Clipper clipper;
            clipper.AddPath(p1, ClipperLib::ptSubject, true);
            clipper.AddPath(p2, ClipperLib::ptClip, true);
            clipper.Execute(ClipperLib::ctDifference, diff_p1_p2);

            clipper.Clear();
            clipper.AddPath(p1, ClipperLib::ptSubject, true);
            clipper.AddPath(p3, ClipperLib::ptClip, true);
            clipper.Execute(ClipperLib::ctDifference, diff_p1_p3);

            clipper.Clear();
            clipper.AddPath(p2, ClipperLib::ptSubject, true);
            clipper.AddPath(p3, ClipperLib::ptClip, true);
            clipper.Execute(ClipperLib::ctDifference, diff_p2_p3);

// Calculate the areas of the differences
            double area_diff_p1_p2 = 0.0;
            double area_diff_p1_p3 = 0.0;
            double area_diff_p2_p3 = 0.0;

            for (const auto& path : diff_p1_p2) {
                area_diff_p1_p2 += ClipperLib::Area(path);
            }

            for (const auto& path : diff_p1_p3) {
                area_diff_p1_p3 += ClipperLib::Area(path);
            }

            for (const auto& path : diff_p2_p3) {
                area_diff_p2_p3 += ClipperLib::Area(path);
            }

// Output the areas of the differences

            double top_diff = std::max(area_diff_p1_p3, std::max(area_diff_p2_p3, area_diff_p1_p2));
            double top_area = std::max(ClipperLib::Area(p1), std::max(ClipperLib::Area(p2), ClipperLib::Area(p3)));
            mem = std::max(mem, top_diff/top_area);

        }
         */
    }

    if(!timeM){
        OG_poly::Mesh PolyanyaMesh(geomMesh);
        OG_poly::SearchInstance Polyanya(&PolyanyaMesh);
        std::vector<OG_poly::Point> pvis;

        EdgeVis.precompute_edges_searchnodes();
        EdgeVis.precompute_edges_optimnodesV1();
        EdgeVis.precompute_edges_optimnodesV2();
        EdgeVis.precompute_edges_optimnodesV3();

        bool debug = false;
        double steps;
        int debugEdge = 0;
        clock.Restart();
        double mem = 0;
        int ctr = 0;
        double T1, T2, T3;
        for (auto pos: points) {
            ctr++;
            //EdgeVis.reset_visu();
            //std::cout << pos << std::endl;
            //EdgeVis.visualise_point(pos, 0, true);

            verticesPoly = EdgeVis.find_point_visibility_optim1(pos, T1, T2, T3);

            auto polymem = verticesPoly;
            ClipperLib::Path p1, p2, p3;
            for (const auto& point : verticesPoly) {
                p1.push_back(ClipperLib::IntPoint(static_cast<long>(point.x),
                                                  static_cast<long>(point.y )));
            }

            verticesPoly = EdgeVis.find_point_visibility_optim2(pos);
            for (const auto& point : verticesPoly) {
                p2.push_back(ClipperLib::IntPoint(static_cast<long>(point.x),
                                                  static_cast<long>(point.y )));
            }

//            verticesPoly = EdgeVis.find_point_visibility_optim3(pos);
//            for (const auto& point : verticesPoly) {
//                p3.push_back(ClipperLib::IntPoint(static_cast<long>(point.x),
//                                                  static_cast<long>(point.y )));
//            }

            double T1, T2, T3;
            pvis = Polyanya.get_point_visibility({pos.x, pos.y}, T1, T2, T3);
            for(auto p : pvis){
                p3.push_back(ClipperLib::IntPoint(static_cast<long>(p.x),
                                                  static_cast<long>(p.y )));
            }

            ClipperLib::Paths diff_p1_p2, diff_p1_p3, diff_p2_p3;
            ClipperLib::Clipper clipper;
            clipper.AddPath(p1, ClipperLib::ptSubject, true);
            clipper.AddPath(p2, ClipperLib::ptClip, true);
            clipper.Execute(ClipperLib::ctDifference, diff_p1_p2);

            clipper.Clear();
            clipper.AddPath(p1, ClipperLib::ptSubject, true);
            clipper.AddPath(p3, ClipperLib::ptClip, true);
            clipper.Execute(ClipperLib::ctDifference, diff_p1_p3);

            clipper.Clear();
            clipper.AddPath(p2, ClipperLib::ptSubject, true);
            clipper.AddPath(p3, ClipperLib::ptClip, true);
            clipper.Execute(ClipperLib::ctDifference, diff_p2_p3);

            double area_diff_p1_p2 = 0.0;
            double area_diff_p1_p3 = 0.0;
            double area_diff_p2_p3 = 0.0;

            for (const auto& path : diff_p1_p2) {
                area_diff_p1_p2 += ClipperLib::Area(path);
            }

            for (const auto& path : diff_p1_p3) {
                area_diff_p1_p3 += ClipperLib::Area(path);
            }

            for (const auto& path : diff_p2_p3) {
                area_diff_p2_p3 += ClipperLib::Area(path);
            }

            // Output the areas of the differences

            double top_diff = std::max(area_diff_p1_p3, std::max(area_diff_p2_p3, area_diff_p1_p2));
            double top_area = std::max(ClipperLib::Area(p1), std::max(ClipperLib::Area(p2), ClipperLib::Area(p3)));
            std::cout << ctr << " - " << top_diff/top_area << std::endl;
            mem = std::max(mem, top_diff/top_area);

        }
        std::cout << mem << std::endl;

    }

    if(timeM)
    {
        edgevis::Mesh EdgeVis3(geomMesh);
        EdgeVis3.useRobustOrientatation = pov.robust;
        clock.Restart();
        EdgeVis3.TEAItems = 200;
        EdgeVis3.realloc_TEA_mem(EdgeVis3.TEAItems);
        int ctr = 0;
        double T1, T2, T3;
        for (auto pos: points) {

            //std::cout << ++ctr << std::endl;
            verticesPoly = EdgeVis3.find_point_visibility_TEA(pos, T1, T2, T3);
            //EdgeVis3.reset_visu();
            //EdgeVis3.visualise_point(pos, 0, false);
            //EdgeVis3.visualise_polygon(verticesPoly, 2, true);
            //getchar();
        }
        EdgeVis3.allocTEA.clear();
        time = clock.TimeInSeconds();
        std::cout << "TEA: " << "\n";
        std::cout << "Total computation time: " << time << " seconds.\n";
        std::cout << "Mean computation time: " << time / pov.n_random_samples << " seconds/point.\n";
        std::cout << std::endl;
        EdgeVis3.reset_visu();
        EdgeVis3.visualise_polygon(verticesPoly, 2, true);
        EdgeVis3.visualise_point(points.back(), 0, true);
    }

    if(timeM)
    {
        edgevis::Mesh EdgeVis2(geomMeshPoly);
        EdgeVis2.useRobustOrientatation = pov.robust;
        clock.Restart();
        EdgeVis2.PEAItems = 200;
        EdgeVis2.realloc_PEA_mem(EdgeVis2.PEAItems);
        double T1, T2, T3;
        for (auto pos: points) {
            //EdgeVis2.reset_visu();
            verticesPoly = EdgeVis2.find_point_visibility_PEA(pos, T1, T2, T3);

            //std::cout <<"size: " << verticesPoly.size()<<std::endl;
            //EdgeVis2.visualise_polygon(verticesPoly, 2, false);
            //EdgeVis2.visualise_point(pos, 0, true);
            //getchar();
        }
        EdgeVis2.allocPEA.clear();
        time = clock.TimeInSeconds();
        std::cout << "PEA: " << "\n";
        std::cout << "Total computation time: " << time << " seconds.\n";
        std::cout << "Mean computation time: " << time / pov.n_random_samples << " seconds/point.\n";
        std::cout << std::endl;
        EdgeVis2.reset_visu();
        EdgeVis2.visualise_polygon(verticesPoly, 2, true);
        EdgeVis2.visualise_point(points.back(), 0, true);
    }

    if(timeM)
    {

        polyanya::PolyVis polyvis(geomMesh);
        std::vector<polyanya::Point> pointsP = polyvis.generate_points(pov.n_random_samples);
        pointsP.clear();
        for(auto pos : points){
            pointsP.push_back({pos.x, pos.y});
        }
        std::vector<polyanya::Point> results;
        clock.Restart();
        for (auto pos: pointsP) {
            results = polyvis.get_visibility_polygon(pos);
        }

        time = clock.TimeInSeconds();
        std::cout << "TEA initial - bad: " << "\n";
        std::cout << "Total computation time: " << time << " seconds.\n";
        std::cout << "Mean computation time: " << time / pov.n_random_samples << " seconds/point.\n";
        std::cout << std::endl;
    }


    if(timeM)
    {

        polyanya::PolyVis polyvis(geomMeshPoly);
        std::vector<polyanya::Point> pointsP = polyvis.generate_points(pov.n_random_samples);
        pointsP.clear();
        for(auto pos : points){
            pointsP.push_back({pos.x, pos.y});
        }
        std::vector<polyanya::Point> results;
        clock.Restart();
        for (auto pos: pointsP) {
            results = polyvis.get_visibility_polygon(pos);
        }

        time = clock.TimeInSeconds();
        std::cout << "PEA initial - bad: " << "\n";
        std::cout << "Total computation time: " << time << " seconds.\n";
        std::cout << "Mean computation time: " << time / pov.n_random_samples << " seconds/point.\n";
        std::cout << std::endl;
    }

    if(timeM)
    {
        edgevis::Mesh EdgeVis3(geomMesh);
        OG_poly::Mesh PolyanyaMesh(geomMesh);
        OG_poly::SearchInstance Polyanya(&PolyanyaMesh);
        std::vector<OG_poly::Point> pointsP = Polyanya.generate_points(pov.n_random_samples);
        pointsP.clear();
        for(auto pos : points){
            pointsP.push_back({pos.x, pos.y});
        }
        std::vector<OG_poly::Point> results;
        clock.Restart();
        double T1, T2, T3;
        for (auto pos: pointsP) {
            results = Polyanya.get_point_visibility(pos, T1, T2, T3);
//            verticesPoly.clear();
//            for(auto p : results){
//                verticesPoly.push_back({p.x, p.y});
//            }
//            EdgeVis3.reset_visu();
//            EdgeVis3.visualise_point({pos.x, pos.y}, 0, false);
//            EdgeVis3.visualise_polygon(verticesPoly, 2, true);
//            getchar();
        }

        time = clock.TimeInSeconds();
        std::cout << "TEA very original: " << "\n";
        std::cout << "Total computation time: " << time << " seconds.\n";
        std::cout << "Mean computation time: " << time / pov.n_random_samples << " seconds/point.\n";
        std::cout << std::endl;
    }

    if(timeM)
    {
        OG_poly::Mesh PolyanyaMesh(geomMeshPoly);
        OG_poly::SearchInstance Polyanya(&PolyanyaMesh);
        std::vector<OG_poly::Point> pointsP = Polyanya.generate_points(pov.n_random_samples);
        pointsP.clear();
        for(auto pos : points){
            pointsP.push_back({pos.x, pos.y});
        }
        std::vector<OG_poly::Point> results;
        clock.Restart();
        double T1, T2, T3;
        for (auto pos: pointsP) {
            results = Polyanya.get_point_visibility(pos, T1, T2, T3);
        }

        time = clock.TimeInSeconds();
        std::cout << "PEA very original: " << "\n";
        std::cout << "Total computation time: " << time << " seconds.\n";
        std::cout << "Mean computation time: " << time / pov.n_random_samples << " seconds/point.\n";
        std::cout << std::endl;
    }

    return 0;
}

int main(
        int argc,
        const char *const *argv
) {
    ProgramOptionVariables pov;
    char c = ParseProgramOptions(argc, argv, pov);
    if (c == 'h') {
        return EXIT_SUCCESS;
    } else if (c == 'e') {
        return EXIT_FAILURE;
    } else {
        return body(pov);
    }
}
