/**
 * File:   trivis_examples.cc
 *
 * Date:   29.11.2021
 * Author: Jan Mikula
 * E-mail: jan.mikula@cvut.cz
 *
 */

// === BOOST INCLUDES ===

#include <boost/program_options.hpp>
#include <boost/filesystem.hpp>

// === TRIVIS INCLUDES ===

#include "trivis/core/tri_vis.h"
#include "trivis/core/geom/robust_geometry.h"
#include "trivis/core/geom/generic_geom_types.h"
#include "trivis/core/utils/simple_clock.h"
#include "trivis/core/utils/clipper_utils.h"
#include "trivis/core/geom/generic_geom_utils.h"

#include "trivis/map_coverage/map_coverage.h"
#include "trivis/map_coverage/random_points.h"
#include "trivis/map_coverage/macs.h"

// === THIS PROJECT INCLUDES ===

#include "data_loading/load_map.h"
#include "drawing/drawing.h"
#include "drawing/random_colors.h"
#include "logging/logging.h"

#ifndef INPUT_MAPS_DIR
#define INPUT_MAPS_DIR "."
#endif

namespace po = boost::program_options;
namespace fs = boost::filesystem;

namespace tv = trivis;
namespace tvc = tv::core;
namespace tvg = tvc::geom;
namespace tve = trivis_examples;
namespace dr = tve::drawing;

/**
 * All program option variables and their default values should be defined here.
 * For each variable, there should be an option added in AddProgramOptions.
 */
struct ProgramOptionVariables {
    bool verbosity_silent = false;
    bool verbosity_quiet = false;
    bool verbosity_verbose = false;
    std::string input_map_name = "undefined";
    std::string input_map_extension = ".txt";
    std::string input_map_dir = INPUT_MAPS_DIR;
    std::string input_map_full_path;
    double map_scale = -1.0;
    double vis_radius = -1.0;
    int n_random_samples = 1;
    unsigned random_seed = std::random_device{}();
};

void AddProgramOptions(
    po::options_description &options_description,
    ProgramOptionVariables &pov
) {
    options_description.add_options()
        ("help,h", "Produce this help message. \n (*) Overwrites options: all.")
        ("verbose,v",
         po::bool_switch(&pov.verbosity_verbose)->default_value(pov.verbosity_verbose),
         "Log messages: fatal, error, warning, info, debug.")
        ("quiet,q",
         po::bool_switch(&pov.verbosity_quiet)->default_value(pov.verbosity_quiet),
         "Log messages: fatal, error, warning. \n (*) Overwrites options: verbose.")
        ("silent,s",
         po::bool_switch(&pov.verbosity_silent)->default_value(pov.verbosity_silent),
         "Log messages: fatal, error. \n (*) Overwrites options: verbose, quiet.")
        ("map-name,m",
         po::value(&pov.input_map_name)->default_value(pov.input_map_name),
         "Map name.")
        ("map-ext",
         po::value(&pov.input_map_extension)->default_value(pov.input_map_extension),
         "Map file extension.")
        ("map-dir",
         po::value(&pov.input_map_dir)->default_value(pov.input_map_dir),
         "Map file directory.")
        ("map",
         po::value(&pov.input_map_full_path)->default_value(pov.input_map_full_path),
         "Full path to the map file. \n (*) Overwrites options: map_name, map_ext, map_dir.")
        ("map-scale,s",
         po::value(&pov.map_scale),
         "Map scale (optional).")
        ("vis-radius,r",
         po::value(&pov.vis_radius)->default_value(pov.vis_radius),
         "Visibility radius (-1 ~ infinite).")
        ("n-random-samples,n",
         po::value(&pov.n_random_samples)->default_value(pov.n_random_samples),
         "How many random samples should be generated.")
        ("random-seed",
         po::value(&pov.random_seed)->default_value(pov.random_seed),
         "Seed for the random generator (generated by std::random_device{}() by default).");
}

tve::logging::severity_level GetSeverity(const ProgramOptionVariables &pov) {
    using namespace tve::logging;
    if (pov.verbosity_silent) {
        return severity_level::error;
    } else if (pov.verbosity_quiet) {
        return severity_level::warning;
    } else if (pov.verbosity_verbose) {
        return severity_level::debug;
    } else {
        return severity_level::info;
    }
}

/**
 *
 * Parses arguments and initializes logging.
 *
 * @param argc Number of arguments.
 * @param argv Array of arguments.
 * @param pov
 * @return Character 'e' if an exception occurred, 'h' if --help option, '0' else.
 */
char ParseProgramOptions(
    int argc,
    const char *const *argv,
    ProgramOptionVariables &pov
) {
    using namespace tve::logging;
    if (argc < 2) {
        InitLogging(severity_level::info);
        LOGF_FTL("No arguments provided. Use --help to see available options.");
        return 'e';
    }
    po::variables_map vm;
    po::options_description command_line_options;
    po::options_description options_description("General options");
    AddProgramOptions(options_description, pov);
    try {
        // Parse the command line arguments.
        command_line_options.add(options_description);
        po::store(po::parse_command_line(argc, argv, command_line_options), vm);
        po::notify(vm);
    } catch (const std::exception &e) {
        // If exception, log it and return 'e'.
        InitLogging(severity_level::info);
        LOGF_FTL("Error in parsing arguments: " << e.what() << ".");
        return 'e';
    }
    if (vm.count("help")) {
        // If '-h' or '--help' option, print the options and return 'h'.
        command_line_options.print(std::cout, 80);
        return 'h';
    }
    InitLogging(GetSeverity(pov));
    // Make input_file_name, input_file_extension, input_file_dir, and input_file_full_path consistent.
    if (pov.input_map_full_path.empty()) {
        pov.input_map_full_path = pov.input_map_dir + "/" + pov.input_map_name + (pov.input_map_extension.empty() ? "" : pov.input_map_extension);
    } else {
        auto aux = fs::path(pov.input_map_full_path);
        pov.input_map_name = fs::change_extension(aux, "").filename().string();
        pov.input_map_extension = aux.extension().string();
        pov.input_map_dir = aux.parent_path().string();
    }
    return '0';
}

tvg::RadialVisibilityRegion ComputeVisibilityRegion(
    const tvg::FPoint &p,
    const tvc::TriVis &vis,
    std::optional<double> vis_radius,
    double eps_min_edge_len
) {
    int num_expansions;
    tvg::AbstractVisibilityRegion abs_vis_reg;
    if (!vis.ComputeVisibilityRegion(p, vis_radius, abs_vis_reg, num_expansions)) {
        LOGF_WRN("Visibility region from seed " << p << " could not be found!");
        return {};
    }
    tvg::RadialVisibilityRegion vis_reg = vis.ConvertToVisibilityRegion(abs_vis_reg);
    RemoveAntennas(vis_reg);
    if (vis_radius) {
        vis_reg = trivis::core::TriVis::ConvertToRadialVisibilityRegion(*vis_radius, vis_reg);
    }
    RemoveShortEdges(eps_min_edge_len, vis_reg);
    return vis_reg;
}

void FancyDrawMap(
    const tve::drawing::MapDrawer &drawer,
    const tvc::TriVis &vis
) {
    drawer.DrawMap();
    drawer.DrawPlane(dr::kColorBlack);
    drawer.DrawBorders(dr::kColorWhite);
    drawer.DrawHoles(dr::kColorDimGray);
    drawer.DrawPolygons(vis.triangles(), 0.01, dr::kColorYellow);
    for (int i = 0; i < vis.mesh().nodes.size(); ++i) {
        drawer.DrawText(std::to_string(i), vis.mesh().point(i), 0.03, dr::kColorNavy);
    }
    for (int i = 0; i < vis.mesh().edges.size(); ++i) {
        drawer.DrawText(std::to_string(i), (vis.mesh().point(vis.mesh().edges[i].nodes[0]) + vis.mesh().point(vis.mesh().edges[i].nodes[1])) / 2.0, 0.03, dr::kColorMaroon);
    }
    for (int i = 0; i < vis.mesh().triangles.size(); ++i) {
        const auto &tri = vis.mesh().triangles[i];
        drawer.DrawText(std::to_string(i), (vis.mesh().point(tri.nodes[0]) + vis.mesh().point(tri.nodes[1]) + vis.mesh().point(tri.nodes[2])) / 3.0, 0.03, dr::kColorDeepPink);
    }
}

void FancyDrawRadialVisibilityRegion(
    const tve::drawing::MapDrawer &drawer,
    const tvg::RadialVisibilityRegion &vis_reg,
    const dr::RGB &c
) {
    dr::RGB c_dark = {static_cast<int>(c.r / 1.5), static_cast<int>(c.g / 1.5), static_cast<int>(c.b / 1.5)};
    dr::RGB c_darker = {static_cast<int>(c.r / 2.5), static_cast<int>(c.g / 2.5), static_cast<int>(c.b / 2.5)};
    drawer.DrawArc(vis_reg.seed, 0.30, 0.0, 2.0 * M_PI, 0.01, c_dark);
    drawer.DrawArc(vis_reg.seed, 0.20, 0.0, 2.0 * M_PI, 0.01, c_dark);
    drawer.DrawPoint(vis_reg.seed, 0.10, c);
    drawer.DrawPoint(vis_reg.seed, 0.09, c_dark);
    drawer.DrawPoint(vis_reg.seed, 0.08, c);
    drawer.DrawPoint(vis_reg.seed, 0.07, c_dark);
    drawer.DrawPoint(vis_reg.seed, 0.06, c);
    drawer.DrawPoint(vis_reg.seed, 0.05, c_dark);
    drawer.DrawPoint(vis_reg.seed, 0.04, c);
    drawer.DrawPoint(vis_reg.seed, 0.03, c_dark);
    drawer.DrawPoint(vis_reg.seed, 0.02, c);
    drawer.DrawPoint(vis_reg.seed, 0.01, c_dark);
    auto reg_with_arcs_samples = tv::map_coverage::SampleArcEdges(vis_reg, M_PI / 180);
    auto polygon = tvc::TriVis::ConvertToPolygon(reg_with_arcs_samples);
    if (vis_reg.radius > 0) {
        drawer.DrawArc(vis_reg.seed, vis_reg.radius, 0.0, 2.0 * M_PI, 0.025, c, 0.1);
    }
    drawer.DrawPolygon(polygon, c, 0.5);
    if (vis_reg.vertices.size() <= 1) {
        drawer.DrawArc(vis_reg.seed, vis_reg.radius, 0.0, 2.0 * M_PI, 0.05, c);
    } else {
        for (int i_prev = static_cast<int>(vis_reg.vertices.size()) - 1, i = 0; i < vis_reg.vertices.size(); i_prev = i++) {
            const auto &vi_prev = vis_reg.vertices[i_prev];
            const auto &vi = vis_reg.vertices[i];
            if (vi.edge_flag > -1) {
                drawer.DrawLine(vi_prev.point, vi.point, 0.05, c_darker);
            } else if (vi.edge_flag == -1) {
                drawer.DrawLine(vi_prev.point, vi.point, 0.05, c_dark);
            } else if (vi.edge_flag == -2) {
                drawer.DrawLine(vi_prev.point, vi.point, 0.05, c, 0.1);
                auto a = vi.point - vis_reg.seed;
                auto b = vi_prev.point - vis_reg.seed;
                drawer.DrawArc(vis_reg.seed, vis_reg.radius, std::atan2(a.x, a.y) - M_PI_2, std::atan2(b.x, b.y) - M_PI_2, 0.05, c);
            } else if (vi.edge_flag == -3) {
                drawer.DrawLine(vi_prev.point, vi.point, 0.05, c_dark);
            } else {
                drawer.DrawLine(vi_prev.point, vi.point, 0.05, c);
            }
        }
        for (int i_prev = static_cast<int>(vis_reg.vertices.size()) - 1, i = 0; i < vis_reg.vertices.size(); i_prev = i++) {
            const auto &vi_prev = vis_reg.vertices[i_prev];
            const auto &vi = vis_reg.vertices[i];
            auto u = vi_prev.point - vi.point;
            double norm = u.Norm();
            u = u / u.Norm();
            std::string text = std::to_string(i);
            if (vi.edge_flag >= 0) {
                text += "-" + std::to_string(vi.edge_flag);
            }
            drawer.DrawText(text, vi.point + u * norm * 0.5, 0.03, dr::kColorBlack);
        }
        for (int i_prev = static_cast<int>(vis_reg.vertices.size()) - 1, i = 0; i < vis_reg.vertices.size(); i_prev = i++) {
            const auto &vi_prev = vis_reg.vertices[i_prev];
            const auto &vi = vis_reg.vertices[i];
            if (vi.edge_flag > 0) {
                drawer.DrawPoint(vi.point, 0.03, c_darker);
            } else if (vi.edge_flag == -1) {
                drawer.DrawPoint(vi.point, 0.03, c_dark);
            } else if (vi.edge_flag == -2) {
                drawer.DrawPoint(vi.point, 0.03, c);
            } else if (vi.edge_flag == -3) {
                drawer.DrawPoint(vi.point, 0.03, c_dark);
            } else {
                drawer.DrawPoint(vi.point, 0.03, c);
            }
            drawer.DrawPoint(vi.point, 0.02, vi.vertex_flag == -1 ? dr::kColorGray : dr::kColorWhite);
        }
        for (int i_prev = static_cast<int>(vis_reg.vertices.size()) - 1, i = 0; i < vis_reg.vertices.size(); i_prev = i++) {
            const auto &vi_prev = vis_reg.vertices[i_prev];
            const auto &vi = vis_reg.vertices[i];
            std::string text = std::to_string(i);
            if (vi.vertex_flag >= 0) {
                text += "-" + std::to_string(vi.vertex_flag);
            }
            drawer.DrawText(text, vi.point, 0.03, dr::kColorBlack);
        }
    }
}

/**
 *
 *  ##########################################
 *  ## THIS IS THE MAIN BODY OF THE PROGRAM ##
 *  ##########################################
 *
 * @param pov ~ program option variables
 * @return exit code
 */
int MainBody(const ProgramOptionVariables &pov) {


    // Create and initialize TriVis object.
    tvc::TriVis vis;
    {   // Load map from file and move it to TriVis (without copying).
        tvg::PolyMap map;
        std::string load_msg = tve::data_loading::LoadPolyMapSafely(pov.input_map_full_path, map, pov.map_scale);
        if (load_msg != "ok") {
            LOGF_FTL("Error while loading map. " << load_msg);
            return EXIT_FAILURE;
        }
        map.RemoveDuplicatePoints();
        map.RemoveCollinearPoints();
        vis.SetMap(std::move(map));
        // cannot use map anymore
    }
    vis.TriangulateMapConstrainedDelaunay();
    vis.FillBucketing();
    vis.OptimizeBuckets();

    // Create a helper object for drawing.
    auto drawer = tve::drawing::MakeMapDrawer(vis.map());

    // Generate n random points in the map.
    std::vector<double> triangle_accum_areas; // auxiliary structure to improve speed
    std::mt19937 rng(pov.random_seed); // random generator
    tvg::FPoints random_points(pov.n_random_samples);
    for (auto &rp: random_points) {
        rp = tv::map_coverage::UniformRandomPointInRandomTriangle(vis.triangles(), triangle_accum_areas, rng);
    }

    // Compute a visibility region for each sample.
    std::optional<double> vis_radius = pov.vis_radius > 0.0 ? std::make_optional(pov.vis_radius) : std::nullopt;
    std::vector<tvg::RadialVisibilityRegion> regions;
    regions.reserve(random_points.size());
    tvc::utils::SimpleClock clock;
    for (const auto &rp: random_points) {
        regions.push_back(ComputeVisibilityRegion(rp, vis, vis_radius, 1e-6));
    }
    double time = clock.TimeInSeconds();
    LOGF_INF("Total time: " << time << " s.");
    LOGF_INF("Mean time: " << time / regions.size() << " s.");

    // Draw map and the regions.
    drawer.OpenPDF("regions.pdf");
    FancyDrawMap(drawer, vis);
    auto colors = dr::RandomColors(static_cast<int>(regions.size()), 0);
    for (auto &c: colors) c = dr::CairoGeomDrawer::SaturateColor(c);
    for (int i = 0; i < regions.size(); ++i) {
        const auto &region = regions[i];
        FancyDrawRadialVisibilityRegion(drawer, region, colors[i]);
        drawer.DrawText(std::to_string(i), region.seed, 0.15);
    }
    drawer.Close();

    return EXIT_SUCCESS;
}

int main(
    int argc,
    const char *const *argv
) {
    ProgramOptionVariables pov;
    char c = ParseProgramOptions(argc, argv, pov);
    if (c == 'h') {
        return EXIT_SUCCESS;
    } else if (c == 'e') {
        return EXIT_FAILURE;
    } else {
        return MainBody(pov);
    }
}